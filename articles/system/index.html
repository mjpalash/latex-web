<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>A Systems Approach to Understanding Distributed Systems
Patterns</title>

  <style>
    /* --- Base Typography --- */
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                   Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      line-height: 1.6;
      color: #222;
      background: #fdfdfd;
    }

    /* Smart dark mode */
    @media (prefers-color-scheme: dark) {
      body {
        color: #e0e0e0;
        background: #111;
      }
      a { color: #8ab4f8; }
      code { background: #222; }
      pre code { background: #111; }
      blockquote { color: #ccc; border-left-color: #444; }
      table th { background: #222; }
      table td { background: #111; }
    }

    /* --- Page Container --- */
    .container {
      max-width: 860px;
      padding: 40px 20px;
      margin: 0 auto;
    }

    /* --- Title Block --- */
    h1.title {
      font-size: 2.4em;
      font-weight: 700;
      margin-bottom: 0.2em;
      text-align: center;
    }
    .subtitle {
      text-align: center;
      font-style: italic;
      color: #666;
      margin-bottom: 2em;
    }
    .author, .date {
      text-align: center;
      color: #666;
      margin-top: -0.5em;
    }

    /* --- Headings --- */
    h1, h2, h3, h4 {
      margin-top: 2em;
      margin-bottom: 0.6em;
      font-weight: 600;
      color: #333;
    }
    @media (prefers-color-scheme: dark) {
      h1, h2, h3, h4 { color: #e0e0e0; }
    }

    /* --- Paragraphs & Lists --- */
    p {
      margin: 1em 0;
      font-size: 1.08em;
    }
    li {
      margin: 0.4em 0;
    }

    /* --- Code Blocks --- */
    pre {
      padding: 12px;
      background: #f4f4f4;
      overflow-x: auto;
      border-radius: 6px;
      border: 1px solid #ddd;
    }
    pre code {
      font-size: 0.95em;
      background: none;
    }
    code {
      background: #f4f4f4;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 0.95em;
    }

    /* --- Links --- */
    a {
      color: #005cc5;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }

    /* --- Blockquotes --- */
    blockquote {
      margin: 1.5em 0;
      padding-left: 1em;
      border-left: 4px solid #ccc;
      color: #555;
      font-style: italic;
    }

    /* --- Tables --- */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5em 0;
      font-size: 0.95em;
    }
    th, td {
      padding: 10px;
      border: 1px solid #ddd;
    }
    th {
      background: #f0f0f0;
      font-weight: 600;
    }

    /* --- Images --- */
    img {
      max-width: 100%;
      display: block;
      margin: 1.2em auto;
    }

    /* --- MathJax adjustments (optional) --- */
    .math.display {
      margin: 1.5em 0;
      text-align: center;
    }
  </style>

  
      true
  
</head>

<body>
<div class="container">

      <h1 class="title">A Systems Approach to Understanding Distributed
Systems Patterns</h1>
  
  
      <div class="author">Mrityunjay Kumar</div>
      <div class="author">Venkatesh Choppella</div>
  
  
  <hr style="margin: 2em 0; border: 0; border-top: 1px solid #ccc;" />

  <h1 id="introduction">Introduction</h1>
  <p>Patterns used for describing distributed systems often are complex
  and written using code. This makes them hard for novice engineers to
  understand. Additionally, such systems are described as a <em>fait
  accompli</em>, and they do not explicate how such a clever pattern was
  arrived at. This limits the opportunities to understand the pattern by
  understanding its path of evolution (TODO: <em><strong><span
  style="color: red">citation</span></strong></em>). In this paper, we
  want to explore key distributed systems patterns and demonstrate a
  possible evolution path using a <em>successive refinement</em> method
  so that it is easier for novice engineers to understand. We test this
  claim (that our description is understood better) by running a small
  experiment where we ask two groups of students to read two different
  versions of the patterns (one version for each group) - one from a
  textbook and another from our paper - and tested them on their pattern
  understanding.</p>
  <h1 id="write-ahead-log">Write-ahead log</h1>
  <h2 id="problem-statement">Problem statement</h2>
  <p>When a client interacts with a server and submits some data to be
  stored, and the server accepts it, the client would like the guarantee
  that the data is available for retrieval later on, irrespective of
  what happens with the server.</p>
  <p>In the following sections, we will only model using
  <em>transparent</em> systems: systems whose observation space is the
  same as the state space and whose display map is an identity function.
  So, we will omit defining <span class="math inline">\(Y\)</span> and
  <span class="math inline">\(h\)</span>.</p>
  <h2 id="solution---take-1">Solution - Take 1</h2>
  <figure id="fig:wal-take1">
  <img src="images/WAL-1.png" style="width:50.0%" />
  <figcaption>Write-ahead log system: Take 1. set(k,v) is a user
  environment action that supplies a key value pair. crash is a system
  environment action that causes the system to crash (wipe out in-memory
  storage and restart) </figcaption>
  </figure>
  <p>Let’s consider a system that stores the data when a ’set’ action is
  applied. Set action comes with a key-value pair that needs to be
  stored. The LTS <span class="math inline">\(S =
  \{X,X^0,U,f,Y,h\}\)</span> can be written as follows:</p>
  <div class="description">
  <p><span class="math inline">\(X = Dictionary(KVPair), KVPair =
  \{(k,v) | k \in \mathbb{N}, v \in \mathbb{N}\}\)</span>, a dictionary
  with the keys from the key-value pairs <span
  class="math inline">\((k,v)\)</span> received through set actions.</p>
  <p><span class="math inline">\(X^0 = dict()\)</span>, an empty
  dictionary</p>
  <p><span class="math inline">\(U = \{set(k,v), crash\}\)</span>, <span
  class="math inline">\(set\)</span> action supplies a key-value pair to
  be stored, and <span class="math inline">\(crash\)</span> action
  restarts the server, wiping any in-memory content and putting it in
  the initial state.</p>
  </div>
  <p>The transition function <span class="math inline">\(f\)</span> for
  <span class="math inline">\(S\)</span>:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f(x,u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == set(k,v)) <span
  class="math inline">\((x[k] = v)\)</span> // Insert into the
  dictionary <span class="math inline">\(x&#39;\)</span> = <span
  class="math inline">\(x\)</span> if (<span
  class="math inline">\(u\)</span> == crash) <span
  class="math inline">\(x&#39;\)</span> = <span
  class="math inline">\(dict()\)</span></p>
  </div>
  <h3 id="does-the-solution-work">Does the solution work?</h3>
  <p>A <span class="math inline">\(run\)</span> R of <span
  class="math inline">\(S\)</span>, of order <span
  class="math inline">\(n\)</span>, is the sequence <span
  class="math inline">\(\{x_i \xrightarrow{u_i} x_{i+1} \mid i \in
  [0,n)\}\)</span>.</p>
  <p>Let’s consider the following run of the system:</p>
  <p><span class="math inline">\(\{\} \xrightarrow{set(k1,v1)}
  \{(k1,v1)\} \xrightarrow{set(k2,v2)} \{((k1,v1),(k2,v2))\}
  \xrightarrow{crash} \{\}\)</span></p>
  <p>In this run, the system stores two key-value pairs and then loses
  both after a restart action. Thus, the system does not keep its
  guarantee.</p>
  <h2 id="solution-take-2">Solution: Take 2</h2>
  <figure id="fig:wal-take2">
  <img src="images/WAL-2.png" style="width:50.0%" />
  <figcaption>Write-ahead log system: Take 2</figcaption>
  </figure>
  <p>The problem of <span class="math inline">\(S\)</span> is that
  in-memory storage is used, which is wiped out on a crash. One way of
  addressing the problem is to store the information in a persistent
  store for later retrieval. We can use a database for this.</p>
  <p>Using a database brings its own complications: it is not efficient
  to send a request to the database for every key-value pair; we want to
  chunk them and send a request to store the chunk.</p>
  <p>For illustration, let’s assume the chunk size for database requests
  is CHUNKSIZE (CHUNKSIZE pairs form a complete chunk).</p>
  <p>The server now has to be modified in the following way:</p>
  <ol>
  <li><p>It only stores the pairs that are not yet stored in
  database.</p></li>
  <li><p>When it receives a pair to store, and it completes the chunk,
  the server also issues a request to store the chunk.</p></li>
  </ol>
  <p>We will modify the system definition and define the LTS <span
  class="math inline">\(P = \{X,X^0,U,f,Y,h\}\)</span>:</p>
  <div class="description">
  <p><span class="math inline">\(X = \{(i,d) | i \in
  Disctionary(KVPair), d \in Dictionary(KVPair)\}, KVPair = \{(k,v) | k
  \in \mathbb{N}, v \in \mathbb{N}\}\)</span>. The state consists of
  tuple <span class="math inline">\((i,d)\)</span> where <span
  class="math inline">\(i\)</span> is the in-memory chunk and <span
  class="math inline">\(d\)</span> is the latest chunk sent for
  persistent store.</p>
  <p><span class="math inline">\(X^0 = \{dict(),dict()\}\)</span>,</p>
  <p><span class="math inline">\(U = \{set(k,v), crash,
  call(D,store(d))\}\)</span>, <span class="math inline">\(set\)</span>
  action supplies a pair to be stored, and <span
  class="math inline">\(crash\)</span> action restarts the server,
  wiping any in-memory content, and putting it in the initial state,
  while call(D,store) is a call action to send the request to D to store
  the chunk.</p>
  </div>
  <p>The transition function <span class="math inline">\(f\)</span> for
  <span class="math inline">\(P\)</span>:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f((i,d),u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == set(k,v)) <span
  class="math inline">\(i[k] = v\)</span> // Add the data into the
  in-memory dictionary. if (length(<span
  class="math inline">\(x.i\)</span>) == CHUNKSIZE) // Chunk is ready to
  be persisted</p>
  <p>// Call the other system to store the chunk. call(D,store(i))</p>
  <p><span class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((\phi, i)\)</span> else <span
  class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((i,\phi)\)</span> if (<span
  class="math inline">\(u\)</span> == crash) <span
  class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((dict(),dict())\)</span></p>
  </div>
  <p>The data system is a system <span class="math inline">\(D =
  \{X,X^0,U,f,Y,h\}\)</span> where action set <span
  class="math inline">\(U = \{recvcall(C, store(d))\}\)</span> contains
  a call receive action ’store’, and transition function <span
  class="math inline">\(f\)</span> is defined as follows:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f(x,u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == recvcall(C, store(d))</p>
  <p>// Add the data into the persistent store. status =
  storeActionDB(<span class="math inline">\(x\)</span>,d)</p>
  <p>respond(C, status) // Respond with the status. <span
  class="math inline">\(x&#39;\)</span> = <span
  class="math inline">\(x\)</span></p>
  </div>
  <h3 id="does-the-solution-work-1">Does the solution work?</h3>
  <p>A <span class="math inline">\(run\)</span> R of <span
  class="math inline">\(S\)</span>, of order <span
  class="math inline">\(n\)</span>, is the sequence <span
  class="math inline">\(\{x_i \xrightarrow{u_i} x_{i+1} \mid i \in
  [0,n)\}\)</span>.</p>
  <p>Let’s consider the following run of the system and assume CHUNKSIZE
  = 3:</p>
  <p><span class="math inline">\(\{\} \xrightarrow{set(k1,v1)}
  \{((k1,v1),\phi)\} \xrightarrow{set(k2,v2)}
  \{(((k1,v1),(k2,v2)),\phi)\} \\ \qquad \xrightarrow{set(k3,v3)}
  \{(\phi,((k1,v1),(k2,v2),(k3,v3)))\} \xrightarrow{crash}
  \{\}\)</span></p>
  <p>In this run, the system stores 3 key-value pairs, which are
  persisted since CHUNKSIZE is 3. Even after a restart action, the data
  is persisted in the database. Thus, the system seems to keep its
  guarantee.</p>
  <p>However, consider this run:</p>
  <p><span class="math inline">\(\{\} \xrightarrow{set(k1,v1)}
  \{((k1,v1),\phi)\} \xrightarrow{set(k2,v2)}
  \{(((k1,v1),(k2,v2)),\phi)\} \xrightarrow{crash} \{\}\)</span></p>
  <p>Since CHUNKSIZE is not reached in this run, the pairs are still in
  memory and are wiped out when restart action is applied. Thus, the
  system fails to keep its guarantee.</p>
  <h2 id="subsec:WAL-Take3">Solution: Take 3</h2>
  <figure id="fig:wal-take3">
  <img src="images/WAL-3.png" style="width:75.0%" />
  <figcaption>Write-ahead log system: Take 3</figcaption>
  </figure>
  <p>The problem in the previous solution still exists because the
  portion of the data that has not yet persisted is as vulnerable as
  before. We solve it by introducing another system, a file system. We
  use it to store all the append actions received from the client and to
  retrieve the in-memory pairs during restart. Essentially, it stores
  all the actions performed by the server. In particular, it records the
  user’s intent to append <em>before</em> it is persisted.</p>
  <p>Here is the enhancement done to the dynamics of the server system
  <span class="math inline">\(P\)</span>:</p>
  <ol>
  <li><p>When the system receives a request to append, it also sends a
  request ’logset’ to file system.</p></li>
  <li><p>When the system issues a request to <span
  class="math inline">\(D\)</span> to store the chunk, it also sends a
  request ’logstore’ to the file system.</p></li>
  <li><p>When the system resets its state when a <span
  class="math inline">\(crash\)</span> action is received, it fetches
  all the set actions from the file system that were done since the last
  persist (all ’logset’ actions after the last ’logstore’). It uses
  these entries to restore its chunk before restarting.</p></li>
  </ol>
  <p>The modified system <span class="math inline">\(W =
  \{X,X^0,U,f,Y,h\}\)</span> is modified as follows from <span
  class="math inline">\(P\)</span>:</p>
  <ol>
  <li><p><span class="math inline">\(U = \{set(k,v),crash,
  call(D,store(d)), call(F,logset(d)), call(F,logstore(d)),
  call(F,logfetch()))\}\)</span>. logfetch is a call request which
  receives a list lst from <span class="math inline">\(F\)</span>,
  logset adds a set action to <span class="math inline">\(F\)</span>,
  logstore adds a store action to <span
  class="math inline">\(F\)</span>.</p></li>
  </ol>
  <p>The transition function <span class="math inline">\(f\)</span> for
  <span class="math inline">\(W\)</span>:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f((i,d),u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == set(k,v)) // Add the action to the
  system F. call(F, logset((k,v)),status)</p>
  <p><span class="math inline">\(i[k] = v\)</span> // Add the data into
  the in-memory dictionary.</p>
  <p>if (length(<span class="math inline">\(x.i\)</span>) == CHUNKSIZE)
  // Chunk is ready to be persisted</p>
  <p>// Call the other system to store the chunk. call(D,
  store(i),status)</p>
  <p>// Add the action to the system F call(F, logstore(i),status) <span
  class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((\phi, i)\)</span> else <span
  class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((i,\phi)\)</span> if (<span
  class="math inline">\(u\)</span> == crash) <span
  class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((dict(),dict())\)</span></p>
  <p>// Fetch any lost data and repopulate the in-memory store.
  call(F,logfetch(), (lst, status))</p>
  <p>// Read the list of transactions and populate the dictionary. <span
  class="math inline">\(x.i\)</span> = repopulateMemory(lst)</p>
  <p><span class="math inline">\((i&#39;,d&#39;)\)</span> = <span
  class="math inline">\((x.i,dict())\)</span></p>
  </div>
  <p>The file system <span class="math inline">\(F =
  \{X,X^0,U,f,Y,h\}\)</span> is similar to <span
  class="math inline">\(P\)</span>, with he following modifications:</p>
  <ol>
  <li><p><span class="math inline">\(U = \{recvcall(C, logset(d)),
  recvcall(C, logstore(d)), recvcall(C, logfetch)\}\)</span>, logfetch
  is received when C makes a logfetch call, F responds with a list of
  actions that were logged since the last logstore.</p></li>
  </ol>
  <p>The transition function <span class="math inline">\(f\)</span>:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f(x,u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == recvcall(C, logset(d))</p>
  <p>// Update the state with this new log status = appendActionFS(<span
  class="math inline">\(x\)</span>, set(d)) respond(C, status) //
  Respond with the status. <span class="math inline">\(x&#39;\)</span> =
  <span class="math inline">\(x\)</span> if (<span
  class="math inline">\(u\)</span> == recvcall(C, logstore(d))</p>
  <p>// Update the state with this new log status = appendActionFS(<span
  class="math inline">\(x\)</span>, store(d)) respond(C, status) //
  Respond with the status. <span class="math inline">\(x&#39;\)</span> =
  <span class="math inline">\(x\)</span> if (<span
  class="math inline">\(u\)</span> == recvcall(C, logfetch)
  (data,status) = fetchUnpersistedActionsFS(<span
  class="math inline">\(x\)</span>) respond(C,(data,status)) <span
  class="math inline">\(x&#39;\)</span> = <span
  class="math inline">\(x\)</span></p>
  </div>
  <h3 id="does-the-solution-work-2">Does the solution work?</h3>
  <p>A <span class="math inline">\(run\)</span> R of <span
  class="math inline">\(S\)</span>, of order <span
  class="math inline">\(n\)</span>, is the sequence <span
  class="math inline">\(\{x_i \xrightarrow{u_i} x_{i+1} \mid i \in
  [0,n)\}\)</span>.</p>
  <p>Let’s consider the following run of the system (that didn’t work in
  Take 2) and assume CHUNKSIZE = 3:</p>
  <p><span class="math inline">\(\{\} \xrightarrow{set(k1,v1)}
  \{((k1,v1),\phi)\} \xrightarrow{set(k2,v2)}
  \{(((k1,v1),(k2,v2)),\phi)\} \xrightarrow{crash}
  \{(((k1,v1),(k2,v2)),\phi)\}\)</span></p>
  <p>Even though CHUNKSIZE is not reached in this run, the fetched
  actions from the file system can restore the partially constructed
  chunk. Thus, the system keeps its guarantee in this run.</p>
  <h2 id="subsec:WAL-simplified">A simplified WAL system</h2>
  <p>Note that the key technique that ensures data is persisted across
  crashes is the presence of a log that tracks all the set actions
  performed by the server. If this write-ahead log is available, the
  database can always be recreated. Hence, for the purposes of this
  section, it suffices to focus on the system that consists of the
  server system and the file system (and ignore the database
  system).</p>
  <p>The system <span class="math inline">\(L =
  \{X,X^0,U,f,Y,h\}\)</span> is defined as follows:</p>
  <div class="description">
  <p><span class="math inline">\(X = Dictionary(KVPair), KVPair =
  \{(k,v) | k \in \mathbb{N}, v \in \mathbb{N}\}\)</span>, a dictionary
  with the keys from the key-value pairs <span
  class="math inline">\((k,v)\)</span> received through set actions.</p>
  <p><span class="math inline">\(X^0 = dict()\)</span>, an empty
  dictionary</p>
  <p><span class="math inline">\(U = \{set(k,v),crash,
  call(F,logset(d)), call(F,logfetch()))\}\)</span>. logfetch is a call
  request that receives a list from <span
  class="math inline">\(F\)</span>, logset adds a set action to <span
  class="math inline">\(F\)</span>.</p>
  </div>
  <p>Figure <a href="#fig:wal-take4" data-reference-type="ref"
  data-reference="fig:wal-take4">4</a> shows this simplified system.</p>
  <figure id="fig:wal-take4" data-latex-placement="h">
  <img src="images/WAL-4.png" style="width:50.0%" />
  <figcaption>Write-ahead log system: Take 4</figcaption>
  </figure>
  <p>The transition function <span class="math inline">\(f\)</span> for
  <span class="math inline">\(L\)</span>:</p>
  <div class="sdsltf">
  <p><span class="math inline">\(f(x,u) \equiv\)</span> if (<span
  class="math inline">\(u\)</span> == set(k,v)) // Add the action to the
  system F. call(F, logset((k,v)),status)</p>
  <p><span class="math inline">\(x[k] = v\)</span> // Add the data into
  the in-memory dictionary.</p>
  <p>if (<span class="math inline">\(u\)</span> == crash)</p>
  <p>// Fetch any lost data and repopulate the in-memory store.
  call(F,logfetch(), (lst, status))</p>
  <p>// Read the list of transactions and populate the dictionary stored
  in the state. <span class="math inline">\(x&#39;\)</span> =
  repopulateMemory(lst)</p>
  </div>
  <p>The file system <span class="math inline">\(F =
  \{X,X^0,U,f,Y,h\}\)</span> is as defined previously in Section <a
  href="#subsec:WAL-Take3" data-reference-type="ref"
  data-reference="subsec:WAL-Take3">2.4</a>.</p>
  <h2 id="how-does-the-call-primitive-work">How does the call primitive
  work?</h2>
  <p>A call requires a call action by the caller and a corresponding
  recvcall action by the callee.</p>
  <div class="description">
  <p>A call action of the caller is written as call (system, action)
  where the system is the system being called, and action is the request
  type, including any data). For example, call(D, store(d)) means a call
  to system D with a request type store with the data d.</p>
  <p>System provides a call primitive call(system, action, result) where
  the system is the system is called, action is the request type, and
  the result is updated with the response received from the system). For
  example, call (F, logset(d), status) calls system F with request type
  logset, and F responds with status.</p>
  <p>Corresponding action on the receiver side is recvcall (system,
  action), where the system is the system that called this system, and
  action is the request type, including any data. For example,
  recvcall(C, logset(d)) means C called this system with request type
  logset with data d.</p>
  <p>System provides a response primitive respond(system, result) where
  the system is the system to respond to, and the result is the result
  of the action performed due to this call.</p>
  </div>
  <h2 id="diagram-notations">Diagram notations</h2>
  <p>The following rules are followed:</p>
  <ol>
  <li><p>A rectangular box represents a system. The label inside the box
  is the name of the system.</p></li>
  <li><p>Environment actions are represented as undirected lines; the
  label shows the environment actions (without showing the
  data).</p></li>
  <li><p>Sometimes, we show user environment actions separate from
  system environment actions like crash. This is done for clarity of
  understanding.</p></li>
  <li><p>Call actions are represented as normal uni-directed arrows. The
  arrow tail shows the caller system, and the arrowhead shows the system
  being called. The label shows the request types in the corresponding
  call and recvcall actions. Note that such an arrow in the diagram says
  that the caller system has a call action, and the system being called
  has a recvcall action with the same request type (and data
  type).</p></li>
  </ol>

</div>
</body>
</html>
